const https = require('https');  
const http = require('http');
const fs = require('fs');
const path = require('path');
const { Telegraf } = require('telegraf');
const crypto = require('crypto');
require('dotenv').config();
const { Sequelize, DataTypes } = require('sequelize');
const url = require('url');

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞ —Å —Ü–µ–Ω–∞–º–∏ –≤ –∑–≤–µ–∑–¥–∞—Ö (–Ω—É–∂–Ω–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–æ–π—Å–∞)
const CUBE_PRICES = {
  'cube1': 50,
  'cube2': 97,
  'cube3': 497,
  'cube4': 5000
};
// slot price
const SLOT_PRICES = {
  stars: 149,
  ton: 0.90
};

const MIME_TYPES = {
  '.html': 'text/html',
  '.js': 'text/javascript',
  '.css': 'text/css',
  '.json': 'application/json',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.gif': 'image/gif',
  '.webp': 'image/webp',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.wasm': 'application/wasm'
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
const isStaticRequest = (pathname) => {
  const ext = path.extname(pathname).toLowerCase();
  return MIME_TYPES[ext] !== undefined;
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∞—Å—Å–µ—Ç–æ–≤
const isHashedAsset = (pathname) => {
  return pathname.startsWith('/assets/') && pathname.match(/[-_][a-zA-Z0-9]{8,}\./);
};

// –†–µ–¥–∏—Å –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
const ADMIN_ID = process.env.ADMIN_TELEGRAM_ID;
const Redis = require('ioredis');
const redis = new Redis({
    host: '127.0.0.1',
    port: 6379,
    retryStrategy: function(times) {
        const delay = Math.min(times * 50, 2000);
        return delay;
    },
    maxRetriesPerRequest: null
});

redis.on('error', (err) => {
    console.error('Redis connection error:', err);
});

redis.on('connect', () => {
    console.log('Successfully connected to Redis');
});

const isAdmin = (telegramId) => {
  return telegramId.toString() === ADMIN_ID;
};

// –°–æ–∑–¥–∞–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö —Å –ª–æ–≥–∞–º–∏ —Ç–æ–ª—å–∫–æ –æ–± –æ—à–∏–±–∫–∞—Ö, —Å–æ–∑–¥–∞–≤–∞—è –ø—É–ª –≤ 50 –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π –∫ –±–¥
const sequelize = new Sequelize(
  process.env.DB_NAME,
  process.env.DB_USER,
  process.env.DB_PASSWORD, 
  {
    host: process.env.DB_HOST,
    dialect: process.env.DB_DIALECT,
    logging: false, // –û—Ç–∫–ª—é—á–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ SQL –ª–æ–≥–∏
    logQueryParameters: false,
    benchmark: false,
    // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–π logger
    logger: {
      error: (err) => {
        // –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ë–î
        if (err.original) { // –û—à–∏–±–∫–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
          console.error('Database Error:', {
            message: err.original.message,
            code: err.original.code,
            timestamp: new Date().toISOString()
          });
        } else if (err.name === 'SequelizeValidationError') { // –û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
          console.error('Validation Error:', {
            message: err.message,
            errors: err.errors.map(e => e.message),
            timestamp: new Date().toISOString()
          });
        } else { // –î—Ä—É–≥–∏–µ –æ—à–∏–±–∫–∏ –∑–∞–ø—Ä–æ—Å–æ–≤
          console.error('Query Error:', {
            message: err.message,
            timestamp: new Date().toISOString()
          });
        }
      }
    },
    pool: {
      max: 50,
      min: 10,
      acquire: 30000,
      idle: 10000
    }
  }
);
sequelize.authenticate()
  .then(() => {
    console.log('Database connection has been established successfully.');
  })
  .catch(err => {
    console.error('Unable to connect to the database:', err);
  });

// –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ:
process.on('SIGINT', async () => {
  try {
    await sequelize.close();
    console.log('Database connection closed.');
    process.exit(0);
  } catch (err) {
    console.error('Error closing database connection:', err);
    process.exit(1);
  }
});

// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –º–æ–¥–µ–ª—å User
const User = sequelize.define('User', {
  telegramId: {
    type: DataTypes.BIGINT, // –ò–∑–º–µ–Ω–∏—Ç—å —Ç–∏–ø —Å STRING –Ω–∞ BIGINT
    allowNull: false,
    unique: true,
    index: true
  },
  username: {
    type: DataTypes.STRING,
    allowNull: true
  },
  referralCode: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true,
    index: true
  },
  referredBy: {
    type: DataTypes.STRING,
    allowNull: true
  },
  referralRewardsCount: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    allowNull: false
  },
  rootBalance: {
    type: DataTypes.DECIMAL(10, 2), // –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π —Å 2 –∑–Ω–∞–∫–∞–º–∏ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π
    defaultValue: 0,
    index: true
  },
  maxEnergy: {
    type: DataTypes.INTEGER,
    defaultValue: 100
  },
  purchasedModes: {
    type: DataTypes.ARRAY(DataTypes.STRING),
    defaultValue: [], 
    allowNull: false
  },
  miners: {
    type: DataTypes.JSONB, // –ò—Å–ø–æ–ª—å–∑—É–µ–º JSONB –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –º–∞—Å—Å–∏–≤–∞ –º–∞–π–Ω–µ—Ä–æ–≤
    defaultValue: [],
    allowNull: false
  },
  maxSlots: {
    type: DataTypes.INTEGER,
    defaultValue: 5,  // –ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ - 5 —Å–ª–æ—Ç–æ–≤
    allowNull: false
  }
});

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –º–æ–¥–µ–ª—å —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
sequelize.sync({ alter: true });
// –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞ —Å –≤–∞—à–∏–º —Ç–æ–∫–µ–Ω–æ–º
const bot = new Telegraf(process.env.POKO_BOT_TOKEN);
// WebApp URL
const webAppUrl = 'https://pokoapp.space';

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start
bot.command('start', async (ctx) => {
  const telegramId = ctx.from.id.toString();
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º first_name –µ—Å–ª–∏ username –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç
  const username = ctx.from.username || ctx.from.first_name || `user_${telegramId}`;
  const referralCode = ctx.message.text.split(' ')[1];

  try {
    let user = await User.findOne({ where: { telegramId } });

    if (!user) {
      const newReferralCode = crypto.randomBytes(4).toString('hex');
      
      user = await User.create({
        telegramId,
        username,
        referralCode: newReferralCode,
        referredBy: referralCode || null
      });

      if (referralCode) {
        const referrer = await User.findOne({ where: { referralCode } });
        if (referrer) {
          console.log(`User ${telegramId} was referred by ${referrer.telegramId}`);
        }
      }
    } else {
      // –û–±–Ω–æ–≤–ª—è–µ–º username –µ—Å–ª–∏ –æ–Ω –∏–∑–º–µ–Ω–∏–ª—Å—è
      if (user.username !== username) {
        await user.update({ username });
      }
      
      // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –Ω–æ –Ω–µ –∏–º–µ–µ—Ç —Ä–µ—Ñ–µ—Ä–µ—Ä–∞ –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –∫–æ–¥
      if (!user.referredBy && referralCode) {
        const referrer = await User.findOne({ where: { referralCode } });
        if (referrer && referrer.telegramId !== telegramId) { // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –Ω–µ —Å–∞–º–æ—Ä–µ—Ñ–µ—Ä–∞–ª
          await user.update({ referredBy: referralCode });
          console.log(`Existing user ${telegramId} was referred by ${referrer.telegramId}`);
        }
      }
    }

     // First message with fire emoji
     await ctx.reply('I see you\'ve located me. I\'ve had my eye on you.');
    
     // Wait 2 seconds
     await new Promise(resolve => setTimeout(resolve, 2000));
     
     // Second message
     await ctx.reply('I sense great power within you. Allegiance to my vision will bring you prosperity.');
     
     // Wait 2 seconds
     await new Promise(resolve => setTimeout(resolve, 2000));
     
     // Third message with fire emoji and webApp button
     await ctx.reply('Will you venture further into the unknown??', {
       reply_markup: {
         inline_keyboard: [
           [{ text: 'Join Poko üëÅ', web_app: { url: webAppUrl } }]
         ]
       }
     });
 
   } catch (error) {
     console.error('Error in start command:', error);
     ctx.reply('An error occurred. Please try again later.');
   }
 });

// –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /paysupport
bot.command('paysupport', async (ctx) => {
  try {
    await ctx.reply('If you have any issues or questions, please contact our moderator:\n@mirror_of_callandra\n\nWith ‚ù§Ô∏è,\nPOKO Team.');
  } catch (error) {
    console.error('Error in paysupport command:', error);
  }
});

// –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
bot.launch();
bot.on('pre_checkout_query', async (ctx) => {
  try {
    await ctx.answerPreCheckoutQuery(true);
  } catch (error) {
    console.error('Error in pre_checkout_query:', error);
  }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ successful_payment
bot.on('successful_payment', async (ctx) => {
  try {
    console.log('=== PAYMENT HANDLER TRIGGERED ===');
    const payment = ctx.message.successful_payment;
    console.log('Payment data:', payment);

    const payload = payment.invoice_payload;
    console.log('Full payload:', payload);

    // –†–∞–∑–±–∏—Ä–∞–µ–º payload
    const parts = payload.split('_');
    const type = parts[0];
    const telegramId = parts[1];
    
    console.log('Parsed payment type:', type);

    const user = await User.findOne({ where: { telegramId } });
    if (!user) {
      console.error('User not found:', telegramId);
      return;
    }

    if (type === 'cube') {
      const cubeType = parts[2];
      console.log(`User ${telegramId} purchased cube: ${cubeType}`);
      
      // –°–æ–∑–¥–∞—ë–º –æ–±—ä–µ–∫—Ç –º–∞–π–Ω–µ—Ä–∞ —Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –æ–Ω —Å–æ–∑–¥–∞—ë—Ç—Å—è 
      // –¥–ª—è –æ–±—ã—á–Ω—ã—Ö –∫—É–±–æ–≤ –≤ –≤–∞—à–µ–π —Å–∏—Å—Ç–µ–º–µ
      const newMiner = {
        type: cubeType,
        purchaseDate: new Date(),
        id: Date.now()
      };
      
      const currentMiners = user.miners || [];
      const updatedMiners = [newMiner, ...currentMiners];
      
      await user.update({ miners: updatedMiners });
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞–∑–≤–∞–Ω–∏—è –∫—É–±–æ–≤ –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è
      const cubeNames = {
        'cube1': 'Superior',
        'cube2': 'Enhanced',
        'cube3': 'Excellent',
        'cube4': 'Prime'
      };
      
      await ctx.reply(`üéÅ –í—ã —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–æ–±—Ä–µ–ª–∏ ${cubeNames[cubeType]} –∫—É–±!`);
    } else if (type === 'slot') {
      console.log(`User ${telegramId} purchased additional slot`);
      
      // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ—Ç–æ–≤ –∏ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –Ω–∞ 1
      const currentSlots = user.maxSlots || 5;
      const newMaxSlots = currentSlots + 1;
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ—Ç–æ–≤ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
      await user.update({ maxSlots: newMaxSlots });
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—à–Ω–æ–π –ø–æ–∫—É–ø–∫–µ
      await ctx.reply(`üéØ –í—ã —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–æ–±—Ä–µ–ª–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å–ª–æ—Ç!\n–¢–µ–ø–µ—Ä—å —É –≤–∞—Å ${newMaxSlots} —Å–ª–æ—Ç–æ–≤.`);
      
      console.log(`Updated slots for user ${telegramId}: ${newMaxSlots}`);
    } else {
      console.error('Unknown payment type:', type);
      await ctx.reply('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.');
    }
  } catch (error) {
    console.error('Error in successful_payment:', error);
    console.error('Full error:', error.stack);
    try {
      await ctx.reply('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.');
    } catch (replyError) {
      console.error('Error sending error message:', replyError);
    }
  }
});

function validateInitData(initData) {
  const urlParams = new URLSearchParams(initData);
  const hash = urlParams.get('hash');
  urlParams.delete('hash');
  
  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
  const params = Array.from(urlParams.entries())
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([key, value]) => `${key}=${value}`)
    .join('\n');
    
  // –°–æ–∑–¥–∞–µ–º HMAC
  const secret = crypto.createHmac('sha256', 'WebAppData')
    .update(process.env.POKO_BOT_TOKEN)
    .digest();
    
  const generatedHash = crypto.createHmac('sha256', secret)
    .update(params)
    .digest('hex');
    
  return generatedHash === hash;
}

async function authMiddleware(req, res) {
  const initData = req.headers['x-telegram-init-data'];
  if (!initData || !validateInitData(initData)) {
    return { status: 401, body: { error: 'Unauthorized' } };
  }
  return null;
}

const getRequestBody = (req) => {
  return new Promise((resolve, reject) => {
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });
    req.on('end', () => {
      try {
        resolve(JSON.parse(body));
      } catch (error) {
        reject(error);
      }
    });
  });
};

const routes = {
  GET: {
 '/get-user': async (req, res, query) => {
  // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
  const authError = await authMiddleware(req, res);
  if (authError) return authError;

  const telegramId = query.telegramId;
  
  if (!telegramId) {
    return { 
      status: 400, 
      body: { error: 'Telegram ID is required' } 
    };
  }

  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ initData —Å –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º—ã–º ID
    const initData = new URLSearchParams(req.headers['x-telegram-init-data']);
    const userData = JSON.parse(initData.get('user'));
    if (userData.id.toString() !== telegramId) {
      return { 
        status: 403, 
        body: { error: 'Unauthorized: User ID mismatch' } 
      };
    }

    let user = await User.findOne({ where: { telegramId } });
    
    if (user) {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–≥–æ –∫–æ–¥–∞
      if (!user.referralCode) {
        const newReferralCode = Math.random().toString(36).substring(2, 8).toUpperCase();
        await user.update({ referralCode: newReferralCode });
        user = await User.findOne({ where: { telegramId } }); // –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      }

      return { 
        status: 200, 
        body: {
          success: true,
          user: {
            id: user.id,
            telegramId: user.telegramId,
            username: user.username,
            referralCode: user.referralCode,
            rootBalance: user.rootBalance,
            referredBy: user.referredBy,
            maxSlots: user.maxSlots
          }
        }
      };
    }
    return { 
      status: 404, 
      body: { 
        success: false,
        error: 'User not found' 
      } 
    };
  } catch (error) {
    console.error('Error getting user:', error);
    return { 
      status: 500, 
      body: { error: 'Failed to get user' } 
    };
  }
},
    '/get-root-balance': async (req, res, query) => {
      const telegramId = query.telegramId;
      
      if (!telegramId) {
        return { 
          status: 400, 
          body: { error: 'Missing telegramId parameter' } 
        };
      }
  
      try {
        const user = await User.findOne({ where: { telegramId } });
        if (!user) {
          return { 
            status: 404, 
            body: { 
              success: false,
              error: 'User not found' 
            } 
          };
        }
  
        return { 
          status: 200, 
          body: { 
            success: true,
            rootBalance: user.rootBalance,
            user: {
              telegramId: user.telegramId,
              username: user.username,
              referralCode: user.referralCode
            }
          } 
        };
      } catch (error) {
        console.error('Error getting root balance:', error);
        return { 
          status: 500, 
          body: { 
            success: false,
            error: 'Internal server error' 
          } 
        };
      }
    },
    '/get-referral-link': async (req, res, query) => {
      console.log('–ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å –Ω–∞ /get-referral-link');
      const telegramId = query.telegramId;
      
      if (!telegramId) {
        console.log('–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç telegramId');
        return { status: 400, body: { error: 'Missing telegramId parameter' } };
      }

      try {
        console.log('–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å telegramId:', telegramId);
        const user = await User.findOne({ where: { telegramId } });
        if (user) {
          const inviteLink = `https://t.me/ThePokoBot?start=${user.referralCode}`;
          console.log('–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞ —Å—Å—ã–ª–∫–∞:', inviteLink);
          return { status: 200, body: { inviteLink } };
        } else {
          console.log('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
          return { status: 404, body: { error: 'User not found' } };
        }
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞:', error);
        return { status: 500, body: { error: 'Internal server error' } };
      }
    },
    
    '/get-referral-count': async (req, res, query) => {
      const authError = await authMiddleware(req, res);
      if (authError) return authError;

      console.log('Request query:', query);
      console.log('Request URL:', req.url);
      
      const telegramId = query?.telegramId;
      
      if (!telegramId) {
        console.error('No telegramId provided in request');
        return { 
          status: 400, 
          body: { 
            success: false, 
            error: 'Telegram ID is required' 
          } 
        };
      }

      try {
        const user = await User.findOne({ where: { telegramId } });
        console.log('Found user:', user);

        if (!user) {
          return { 
            status: 404, 
            body: { 
              success: false, 
              error: 'User not found' 
            } 
          };
        }

        // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤
        const referrals = await User.findAll({
          where: { referredBy: user.referralCode },
          attributes: ['telegramId', 'username', 'createdAt'],
          raw: true
        });

        console.log('Found referrals:', referrals);

        // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
        const formattedReferrals = referrals.map(ref => ({
          id: ref.telegramId,
          username: ref.username || `User_${ref.telegramId}`,
          joinDate: ref.createdAt
        }));

        return {
          status: 200,
          body: {
            success: true,
            count: referrals.length,
            referrals: formattedReferrals
          }
        };
      } catch (error) {
        console.error('Error in get-referral-count:', error);
        return { 
          status: 500, 
          body: { 
            success: false, 
            error: 'Server error' 
          } 
        };
      }
    },
    
    '/check-channel-subscription': async (req, res, query) => {
      const { telegramId, channel } = query;
      
      console.log('–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏:', { telegramId, channel });
      
      if (!telegramId) {
        return { 
          status: 400, 
          body: { error: 'Missing telegramId parameter' } 
        };
      }

      try {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª
        const chatMember = await bot.telegram.getChatMember(`@${channel}`, telegramId);
        console.log('–°—Ç–∞—Ç—É—Å –ø–æ–¥–ø–∏—Å–∫–∏:', chatMember.status);

        const isSubscribed = ['member', 'administrator', 'creator'].includes(chatMember.status);

        if (isSubscribed) {
          const user = await User.findOne({ where: { telegramId } });
          if (!user) {
            return { status: 404, body: { error: 'User not found' } };
          }

          const currentBalance = parseFloat(user.rootBalance) || 0;
          const newBalance = currentBalance + 1000;
          
          await user.update({ rootBalance: newBalance });

          const updatedUser = await User.findOne({ where: { telegramId } });
          
          console.log('–ë–∞–ª–∞–Ω—Å –æ–±–Ω–æ–≤–ª–µ–Ω:', {
            oldBalance: currentBalance,
            newBalance: updatedUser.rootBalance
          });

          return { 
            status: 200, 
            body: { 
              success: true, 
              message: 'Reward claimed successfully!',
              newBalance: updatedUser.rootBalance
            } 
          };
        } else {
          console.log('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω. –°—Ç–∞—Ç—É—Å:', chatMember.status);
          return { 
            status: 400, 
            body: { 
              success: false, 
              error: 'You are not subscribed to the channel',
              status: chatMember.status
            } 
          };
        }
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏:', error);
        return { 
          status: 500, 
          body: { 
            error: 'Failed to check subscription',
            details: error.message 
          } 
        };
      }
    },
'/create-cube-invoice': async (req, res, query) => {
    const { telegramId, cubeType } = query;
    
    if (!telegramId || !cubeType) {
        return { status: 400, body: { error: 'Missing required parameters' } };
    }

    try {
        const user = await User.findOne({ where: { telegramId } });
        if (!user) {
            return { status: 404, body: { error: 'User not found' } };
        }

        // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ —ç—Ç–æ—Ç –∫—É–± —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ –Ω–∞—à–µ–º –ø—Ä–∞–π—Å–µ
        if (!CUBE_PRICES[cubeType]) {
            return { status: 400, body: { error: 'Invalid cube type' } };
        }

        // –ò–º–µ–Ω–∞ –∫—É–±–æ–≤ –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –∏–Ω–≤–æ–π—Å–µ
        const cubeNames = {
            'cube1': 'Superior',
            'cube2': 'Enhanced',
            'cube3': 'Excellent',
            'cube4': 'Prime'
        };

        const title = 'POKO Cube';
        const description = `Purchase ${cubeNames[cubeType]} Cube`;

        const invoice = await bot.telegram.createInvoiceLink({
            title,
            description,
            payload: `cube_${telegramId}_${cubeType}`,
            provider_token: "",
            currency: 'XTR',
            prices: [{
                label: '‚≠êÔ∏è Purchase',
                amount: CUBE_PRICES[cubeType]
            }]
        });

        return { status: 200, body: { slug: invoice } };
    } catch (error) {
        console.error('Error creating cube invoice:', error);
        return { status: 500, body: { error: 'Failed to create invoice' } };
    }
},
'/create-slot-invoice': async (req, res, query) => {
  console.log('–ó–∞–ø—Ä–æ—Å –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –∏–Ω–≤–æ–π—Å–∞ –¥–ª—è —Å–ª–æ—Ç–∞:', query);
  const { telegramId } = query;
  
  if (!telegramId) {
    console.error('–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç telegramId');
    return { status: 400, body: { error: 'Missing telegramId parameter' } };
  }

  try {
    const user = await User.findOne({ where: { telegramId } });
    if (!user) {
      console.error('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω:', telegramId);
      return { status: 404, body: { error: 'User not found' } };
    }

    const title = 'POKO Slot';
    const description = 'Purchase Additional Slot';

    
    const invoice = await bot.telegram.createInvoiceLink({
      title,
      description,
      payload: `slot_${telegramId}`,
      provider_token: "",
      currency: 'XTR',
      prices: [{
        label: '‚≠êÔ∏è Additional Slot',
        amount: SLOT_PRICES.stars
      }]
    });

    console.log('–°–æ–∑–¥–∞–Ω –∏–Ω–≤–æ–π—Å –¥–ª—è —Å–ª–æ—Ç–∞:', invoice);
    return { status: 200, body: { slug: invoice } };
  } catch (error) {
    console.error('Error creating slot invoice:', error);
    return { status: 500, body: { error: 'Failed to create invoice: ' + error.message } };
  }
},
    '/get-friends-leaderboard': async (req, res, query) => {
    const telegramId = query.telegramId;
    
    if (!telegramId) {
        return { status: 400, body: { error: 'Missing telegramId parameter' } };
    }

    try {
        // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const currentUser = await User.findOne({ 
            where: { telegramId },
            attributes: ['telegramId', 'username', 'highScore']
        });

        if (!currentUser) {
            return { status: 404, body: { error: 'User not found' } };
        }

        // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ø-100 –∏–≥—Ä–æ–∫–æ–≤ —Å –Ω–∞–∏–≤—ã—Å—à–∏–º–∏ —Ä–µ–∫–æ—Ä–¥–∞–º–∏
        const topPlayers = await User.findAll({
          where: {
              highScore: {
                  [Sequelize.Op.gt]: 0
              }
          },
          attributes: ['telegramId', 'username', 'highScore'],
          order: [['highScore', 'DESC']],
          limit: 50  // –£–º–µ–Ω—å—à–∞–µ–º –ª–∏–º–∏—Ç –¥–æ 50
      });

        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ
        const leaderboardData = topPlayers.map(player => ({
            id: player.telegramId,
            username: player.username,
            highScore: player.highScore,
            isCurrentUser: player.telegramId === telegramId
        }));

        // –ï—Å–ª–∏ —Ç–µ–∫—É—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤ —Ç–æ–ø-100, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –æ—Ç–¥–µ–ª—å–Ω–æ
        if (!leaderboardData.some(player => player.isCurrentUser)) {
            leaderboardData.push({
                id: currentUser.telegramId,
                username: currentUser.username,
                highScore: currentUser.highScore,
                isCurrentUser: true
            });
        }

        return { 
            status: 200, 
            body: { 
                leaderboard: leaderboardData,
                timestamp: Date.now()
            } 
        };
    } catch (error) {
        console.error('Error getting leaderboard:', error);
        return { status: 500, body: { error: 'Internal server error' } };
    }
},
'/get-user-slots': async (req, res, query) => {
  const authError = await authMiddleware(req, res);
  if (authError) return authError;

  const { telegramId } = query;
  
  if (!telegramId) {
    return { 
      status: 400, 
      body: { error: 'Telegram ID is required' } 
    };
  }

  try {
    const user = await User.findOne({ where: { telegramId } });
    if (!user) {
      return { 
        status: 404, 
        body: { error: 'User not found' } 
      };
    }

    return { 
      status: 200, 
      body: { 
        success: true,
        maxSlots: user.maxSlots 
      } 
    };
  } catch (error) {
    console.error('Error getting slots:', error);
    return { 
      status: 500, 
      body: { error: 'Failed to get slots' } 
    };
  }
},
'/get-user-miners': async (req, res, query) => {
  const authError = await authMiddleware(req, res);
  if (authError) return authError;

  const { telegramId } = query;
  
  if (!telegramId) {
    console.log('No telegramId provided');
    return { 
      status: 400, 
      body: { error: 'Telegram ID is required' } 
    };
  }

  try {
    const user = await User.findOne({ where: { telegramId } });
    if (!user) {
      console.log(`User ${telegramId} not found`);
      return { 
        status: 404, 
        body: { error: 'User not found' } 
      };
    }

    // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞ –º–∞–π–Ω–µ—Ä–æ–≤
    const minerCounts = (user.miners || []).reduce((acc, miner) => {
      acc[miner.type] = (acc[miner.type] || 0) + 1;
      return acc;
    }, {});

    return { 
      status: 200, 
      body: { 
        success: true,
        miners: user.miners || [],
        minerCounts: minerCounts
      } 
    };
  } catch (error) {
    console.error('Error getting miners:', error);
    return { 
      status: 500, 
      body: { error: 'Failed to get miners' } 
    };
  }
}
},
    POST: {
      '/update-root-balance': async (req, res) => {
        const authError = await authMiddleware(req, res);
        if (authError) return authError;
      
        let body = '';
        req.on('data', chunk => { body += chunk; });
        
        return new Promise((resolve) => {
          req.on('end', async () => {
            try {
              const data = JSON.parse(body);
              const { telegramId, rootBalance } = data;
      
              if (!telegramId || rootBalance === undefined) {
                resolve({ status: 400, body: { error: 'Missing required parameters' } });
                return;
              }
      
              const user = await User.findOne({ where: { telegramId } });
              if (!user) {
                resolve({ status: 404, body: { error: 'User not found' } });
                return;
              }
      
              await user.update({ rootBalance });
      
              resolve({
                status: 200,
                body: { 
                  success: true,
                  rootBalance: user.rootBalance
                }
              });
            } catch (error) {
              console.error('Error updating root balance:', error);
              resolve({ 
                status: 500, 
                body: { error: 'Internal server error' } 
              });
            }
          });
        });
      },
  '/create-user': async (req, res) => {
  const authError = await authMiddleware(req, res);
  if (authError) return authError;

  let body = '';
  req.on('data', chunk => { body += chunk; });
  
  return new Promise((resolve) => {
    req.on('end', async () => {
      try {
        const data = JSON.parse(body);
        const { telegramId, username, referralCode, referredBy } = data;
        
        if (!telegramId || !referralCode) {
          resolve({ 
            status: 400, 
            body: { error: 'Telegram ID and referral code are required' } 
          });
          return;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        let user = await User.findOne({ where: { telegramId } });
        
        if (user) {
          resolve({
            status: 200,
            body: {
              success: true,
              user: {
                id: user.id,
                telegramId: user.telegramId,
                username: user.username,
                referralCode: user.referralCode,
                rootBalance: user.rootBalance,
                referredBy: user.referredBy
              }
            }
          });
          return;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –∫–æ–¥ –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
        if (referredBy) {
          const referrer = await User.findOne({ 
            where: { referralCode: referredBy } 
          });
          
          if (referrer) {
            console.log(`User ${telegramId} was referred by ${referrer.telegramId}`);
            
            try {
              // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Ä–µ—Ñ–µ—Ä–µ—Ä—É
              await bot.telegram.sendMessage(
                referrer.telegramId,
                `üéâ New referral! User ${username} joined using your link!\n\nKeep sharing to earn more rewards!`
              );

              // –ü–æ–ª—É—á–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤
              const referralCount = await User.count({
                where: { referredBy: referrer.referralCode }
              });

              // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –≤—ã–¥–∞—Ç—å –Ω–∞–≥—Ä–∞–¥—É
              const newRewardsCount = Math.floor(referralCount / 3);
              const currentRewardsCount = referrer.referralRewardsCount || 0;

              if (newRewardsCount > currentRewardsCount) {
                // –í—ã—á–∏—Å–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–æ–≤—ã—Ö –Ω–∞–≥—Ä–∞–¥
                const rewardsToGive = newRewardsCount - currentRewardsCount;
                const rewardAmount = rewardsToGive * 0.5;

                // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å –∏ —Å—á–µ—Ç—á–∏–∫ –Ω–∞–≥—Ä–∞–¥ —Ä–µ—Ñ–µ—Ä–µ—Ä–∞
                await referrer.update({
                  rootBalance: Number((referrer.rootBalance + rewardAmount).toFixed(2)),
                  referralRewardsCount: newRewardsCount
                });

                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞–≥—Ä–∞–¥–µ
                await bot.telegram.sendMessage(
                  referrer.telegramId,
                  `üéØ Congratulations! You've earned ${rewardAmount} ROOT for inviting ${rewardsToGive * 3} friends!\n\nKeep inviting to earn more!`
                );
              }

            } catch (error) {
              console.error('Failed to process referral rewards:', error);
            }
          } else {
            referredBy = null;
          }
        }

        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user = await User.create({
          telegramId,
          username,
          referralCode,
          rootBalance: 0,
          referredBy: referredBy || null,
          referralRewardsCount: 0
        });

        resolve({
          status: 200,
          body: {
            success: true,
            user: {
              id: user.id,
              telegramId: user.telegramId,
              username: user.username,
              referralCode: user.referralCode,
              rootBalance: user.rootBalance,
              referredBy: user.referredBy
            }
          }
        });
      } catch (error) {
        console.error('Error creating user:', error);
        resolve({ 
          status: 500, 
          body: { error: 'Failed to create user' } 
        });
      }
    });
  });
},
// –ü–æ–∫—É–ø–∫–∞ —Å–ª–æ—Ç–∞ –∑–∞ TON
'/purchase-slot-ton': async (req, res) => {
  const authError = await authMiddleware(req, res);
  if (authError) return authError;

  let body = '';
  req.on('data', chunk => { body += chunk; });
  
  return new Promise((resolve) => {
    req.on('end', async () => {
      try {
        const data = JSON.parse(body);
        console.log('–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –æ –ø–æ–∫—É–ø–∫–µ —Å–ª–æ—Ç–∞ –∑–∞ TON:', data);

        const { telegramId, transactionBoc, userAddress } = data;

        if (!telegramId || !transactionBoc) {
          resolve({ status: 400, body: { error: '–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã' } });
          return;
        }

        const user = await User.findOne({ where: { telegramId } });
        if (!user) {
          resolve({ status: 404, body: { error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' } });
          return;
        }

        console.log('–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–∫—É–ø–∫–∏ —Å–ª–æ—Ç–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', {
          telegramId,
          userAddress
        });

        // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ—Ç–æ–≤
        const newMaxSlots = (user.maxSlots || 5) + 1;
        await user.update({ maxSlots: newMaxSlots });
        
        console.log('–ü–æ–∫—É–ø–∫–∞ —Å–ª–æ—Ç–∞ –∑–∞ TON —É—Å–ø–µ—à–Ω–∞:', {
          telegramId,
          newMaxSlots,
          userAddress
        });

        resolve({
          status: 200,
          body: { 
            success: true,
            message: '–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å–ª–æ—Ç —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–æ–±—Ä–µ—Ç–µ–Ω',
            user: {
              maxSlots: newMaxSlots,
              telegramId: user.telegramId,
              userAddress
            }
          }
        });
        return;

      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–∫—É–ø–∫–∏ —Å–ª–æ—Ç–∞ –∑–∞ TON:', error);
        resolve({ 
          status: 500, 
          body: { 
            error: '–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø–æ–∫—É–ø–∫—É',
            details: error.message 
          }
        });
        return;
      }
    });
  });
},
'/purchase-with-ton': async (req, res) => {
  const authError = await authMiddleware(req, res);
  if (authError) return authError;

  let body = '';
  req.on('data', chunk => { body += chunk; });
  
  return new Promise((resolve) => {
    req.on('end', async () => {
      try {
        const data = JSON.parse(body);
        console.log('–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –æ –ø–æ–∫—É–ø–∫–µ –∑–∞ TON:', data);

        const { telegramId, cubeType, transactionBoc, userAddress } = data;

        if (!telegramId || !cubeType || !transactionBoc) {
          resolve({ status: 400, body: { error: '–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã' } });
          return;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å cubeType
        const validCubeTypes = ['cube1', 'cube2', 'cube3', 'cube4'];
        if (!validCubeTypes.includes(cubeType)) {
          console.error(`–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫—É–±–∞:`, cubeType);
          resolve({ 
            status: 400, 
            body: { error: `–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫—É–±–∞: ${cubeType}` } 
          });
          return;
        }

        const user = await User.findOne({ where: { telegramId } });
        if (!user) {
          resolve({ status: 404, body: { error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' } });
          return;
        }

        console.log('–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–∫—É–ø–∫–∏ –∫—É–±–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', {
          telegramId,
          cubeType,
          userAddress
        });

        // –°–æ–∑–¥–∞—ë–º –æ–±—ä–µ–∫—Ç –º–∞–π–Ω–µ—Ä–∞
        const newMiner = {
          type: cubeType,
          purchaseDate: new Date(),
          id: Date.now()
        };
        
        const currentMiners = user.miners || [];
        const updatedMiners = [newMiner, ...currentMiners];
        
        await user.update({ miners: updatedMiners });
        
        // –ò–º–µ–Ω–∞ –∫—É–±–æ–≤ –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è
        const cubeNames = {
          'cube1': 'Superior',
          'cube2': 'Enhanced',
          'cube3': 'Excellent',
          'cube4': 'Prime'
        };
        
        console.log('–ü–æ–∫—É–ø–∫–∞ –∫—É–±–∞ –∑–∞ TON —É—Å–ø–µ—à–Ω–∞:', {
          telegramId,
          cubeType,
          cubeName: cubeNames[cubeType],
          userAddress
        });

        resolve({
          status: 200,
          body: { 
            success: true,
            message: `–ö—É–± ${cubeNames[cubeType]} —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–æ–±—Ä–µ—Ç–µ–Ω`,
            user: {
              miners: updatedMiners,
              telegramId: user.telegramId,
              userAddress
            }
          }
        });
        return;

      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–∫—É–ø–∫–∏ –∑–∞ TON:', error);
        resolve({ 
          status: 500, 
          body: { 
            error: '–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø–æ–∫—É–ø–∫—É',
            details: error.message 
          }
        });
      }
    });
  });
},
'/update-user-miners': async (req, res) => {
    const authError = await authMiddleware(req, res);
    if (authError) return authError;

    let body = '';
    req.on('data', chunk => { body += chunk; });
    
    return new Promise((resolve) => {
      req.on('end', async () => {
        try {
          const data = JSON.parse(body);
          const { telegramId, miners } = data;

          if (!telegramId || !Array.isArray(miners)) {
            resolve({ 
              status: 400, 
              body: { error: 'Invalid request data' } 
            });
            return;
          }

          const user = await User.findOne({ where: { telegramId } });
          if (!user) {
            resolve({ 
              status: 404, 
              body: { error: 'User not found' } 
            });
            return;
          }

          await user.update({ miners });

          resolve({
            status: 200,
            body: { 
              success: true,
              miners: user.miners
            }
          });
        } catch (error) {
          console.error('Error updating miners:', error);
          resolve({ 
            status: 500, 
            body: { error: 'Failed to update miners' } 
          });
        }
      });
    });
  },
'/admin/add-wallet': async (req, res) => {
  const authError = await authMiddleware(req, res);
  if (authError) return authError;

  let body = '';
  req.on('data', chunk => { body += chunk; });
  
  return new Promise((resolve) => {
    req.on('end', async () => {
      try {
        const data = JSON.parse(body);
        const { adminId, address, balance, mnemonic } = data;
        
        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º balance –≤ —á–∏—Å–ª–æ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π
        const numericBalance = parseFloat(balance);
        
        if (isNaN(numericBalance)) {
          resolve({
            status: 400,
            body: { error: 'Invalid balance value' }
          });
          return;
        }

        const wallet = await ActiveWallet.create({
          address,
          balance: numericBalance,
          mnemonic,
          status: 'active'
        });

        resolve({
          status: 200,
          body: { 
            success: true,
            wallet
          }
        });
      } catch (error) {
        console.error('Add wallet error:', error);
        resolve({ 
          status: 500, 
          body: { 
            error: 'Failed to add wallet',
            details: error.message 
          }
        });
          }
        });
      });
    },
    // –î–æ–±–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Ä–æ—É—Ç –≤ –æ–±—ä–µ–∫—Ç routes.POST
'/update-max-slots': async (req, res) => {
  const authError = await authMiddleware(req, res);
  if (authError) return authError;

  let body = '';
  req.on('data', chunk => { body += chunk; });
  
  return new Promise((resolve) => {
    req.on('end', async () => {
      try {
        const data = JSON.parse(body);
        const { telegramId, newMaxSlots } = data;

        if (!telegramId) {
          resolve({ 
            status: 400, 
            body: { error: 'Telegram ID is required' } 
          });
          return;
        }

        const user = await User.findOne({ where: { telegramId } });
        if (!user) {
          resolve({ 
            status: 404, 
            body: { error: 'User not found' } 
          });
          return;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ROOT
        if (user.rootBalance < 5000) {
          resolve({
            status: 400,
            body: { error: 'Insufficient funds' }
          });
          return;
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ—Ç–æ–≤
        await user.update({ 
          maxSlots: newMaxSlots,
          rootBalance: user.rootBalance - 5000
        });

        resolve({
          status: 200,
          body: { 
            success: true,
            maxSlots: newMaxSlots,
            rootBalance: user.rootBalance - 5000
          }
        });
      } catch (error) {
        console.error('Error updating max slots:', error);
        resolve({ 
          status: 500, 
          body: { error: 'Failed to update max slots' } 
        });
      }
    });
  });
},
  '/admin/broadcast': async (req, res) => {
    const authError = await authMiddleware(req, res);
    if (authError) return authError;
    
    let body = '';
    req.on('data', chunk => { body += chunk; });
    
    return new Promise((resolve) => {
        req.on('end', async () => {
            try {
                const data = JSON.parse(body);
                const adminId = data.adminId.toString();
                
                if (!isAdmin(adminId)) {  // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é isAdmin
                    resolve({
                        status: 403,
                        body: { error: 'Unauthorized: Admin access required' }
                    });
                    return;
                }
  
                      const { message, button } = data;
                      
                      // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
                      const users = await User.findAll();
                      const results = {
                          total: users.length,
                          success: 0,
                          failed: 0
                      };
  
                      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–∞–∂–¥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
                      for (const user of users) {
                          try {
                              const messageData = {
                                  chat_id: user.telegramId,
                                  text: message,
                                  parse_mode: 'HTML'
                              };
  
                              // –ï—Å–ª–∏ –µ—Å—Ç—å –∫–Ω–æ–ø–∫–∞, –¥–æ–±–∞–≤–ª—è–µ–º –µ—ë
                              if (button) {
                                  messageData.reply_markup = {
                                      inline_keyboard: [[{
                                          text: button.text,
                                          web_app: { url: button.url }
                                      }]]
                                  };
                              }
  
                              await bot.telegram.sendMessage(
                                  user.telegramId,
                                  message,
                                  messageData
                              );
                              results.success++;
                          } catch (error) {
                              console.error(`Failed to send message to ${user.telegramId}:`, error);
                              results.failed++;
                          }
                          
                          // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
                          await new Promise(resolve => setTimeout(resolve, 50));
                      }
  
                      resolve({
                          status: 200,
                          body: { 
                              success: true,
                              results
                          }
                      });
                  } catch (error) {
                      console.error('Error in broadcast:', error);
                      resolve({ 
                          status: 500, 
                          body: { error: 'Internal server error: ' + error.message }
                      });
                  }
              });
          });
      }
    }
  };

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ñ–∞–π–ª–æ–≤
const serveStaticFile = (filePath, res) => {
  const extname = String(path.extname(filePath)).toLowerCase();
  const contentType = {
    '.html': 'text/html',
    '.js': 'text/javascript',
    '.css': 'text/css',
    '.json': 'application/json',
    '.png': 'image/png',
    '.jpg': 'image/jpg',
    '.webp': 'image/webp',
    '.gif': 'image/gif',
    '.svg': 'image/svg+xml',
  }[extname] || 'application/octet-stream';

  fs.readFile(filePath, (error, content) => {
    if (error) {
      if(error.code === 'ENOENT') {
        // –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º index.html –¥–ª—è SPA
        fs.readFile(path.join(__dirname, 'dist', 'index.html'), (error, content) => {
          if (error) {
            res.writeHead(404);
            res.end('–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω');
          } else {
            res.writeHead(200, { 'Content-Type': 'text/html' });
            res.end(content, 'utf-8');
          }
        });
      } else {
        res.writeHead(500);
        res.end('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: ' + error.code);
      }
    } else {
      // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
      const headers = { 'Content-Type': contentType };
      
      // –ï—Å–ª–∏ —ç—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
      if (['.png', '.jpg', '.webp', '.gif', '.svg'].includes(extname)) {
        // –ö–µ—à–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ 1 –Ω–µ–¥–µ–ª—é (604800 —Å–µ–∫—É–Ω–¥)
        headers['Cache-Control'] = 'public, max-age=604800, immutable';
        headers['Expires'] = new Date(Date.now() + 604800000).toUTCString();
      }
      
      res.writeHead(200, headers);
      res.end(content, 'utf-8');
    }
  });
};

const options = {
    key: fs.readFileSync('/etc/letsencrypt/live/pokoapp.space/privkey.pem'),
    cert: fs.readFileSync('/etc/letsencrypt/live/pokoapp.space/fullchain.pem')
};
//
const server = https.createServer(options, async (req, res) => {
  const parsedUrl = url.parse(req.url, true);
  const pathname = parsedUrl.pathname;
  const method = req.method;

  // –õ–æ–≥–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ-—Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–ø—Ä–æ—Å—ã
  if (!pathname.startsWith('/assets/') && !pathname.includes('.jpg')) {
    console.log('Incoming request:', { 
      method, 
      pathname,
      query: parsedUrl.query 
    });
  }

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ä–æ—É—Ç–∞ –≤ routes
  if (routes[method]?.[pathname]) {
    try {
      const handler = routes[method][pathname];
      const result = await handler(req, res, parsedUrl.query);
      
      res.writeHead(result.status, { 
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, X-Telegram-Init-Data'
      });
      
      res.end(JSON.stringify(result.body));
      return;
    } catch (error) {
      console.error('Route handler error:', error);
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Internal Server Error' }));
      return;
    }
  }

  // –ï—Å–ª–∏ —Ä–æ—É—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω - –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∫ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π —Ñ–∞–π–ª
  let filePath = path.join(__dirname, 'dist', req.url === '/' ? 'index.html' : req.url);
  serveStaticFile(filePath, res);
});

const httpsPort = 999;
const httpPort = 997;

server.listen(httpsPort, () => {
  console.log(`HTTPS –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${httpsPort}`);
  console.log('Telegram –±–æ—Ç –∑–∞–ø—É—â–µ–Ω');
  console.log(`HTTPS –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ https://pokoapp.space`);
});

// HTTP to HTTPS redirect
http.createServer((req, res) => {
  res.writeHead(301, { "Location": "https://" + req.headers['host'] + req.url });
  res.end();
}).listen(httpPort, () => {
  console.log(`HTTP —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${httpPort} –¥–ª—è –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –Ω–∞ HTTPS`);
});

// Graceful stop
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));